from datetime import datetime, timedelta
from decimal import Decimal

from django.core.exceptions import ValidationError
from django.db.models import Case, Count, F, Q, Sum
from django.db.models import Value as V
from django.db.models import When
from django.db.models.functions import Coalesce, Concat
from django.utils.timezone import make_aware
from rest_framework import permissions, status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response

from analysis.views.helpers import (
    annotate_revenue_on_checkins,
    parse_and_validate_date_range,
)
from declaracions.models import Checkin
from users.models import CustomUser, Report
from workstations.models import WorkStation


@api_view(["GET"])
@permission_classes([permissions.AllowAny])
def admin_revenue_and_issues_report(request):
    """
    Generates a report for administrators detailing collected revenue and
    issue counts per employee (controller) across all workstations within
    a specified date range.

    This endpoint filters check-ins and reports by the provided date range.
    It iterates through all workstations and their associated employees,
    calculating the total incremental revenue generated by each employee
    and counting the number of issues (reports) they submitted.
    `parse_and_validate_date_range` handles robust date validation, and
    `annotate_revenue_on_checkins` efficiently calculates revenue at the
    database level, replacing manual Python loops.

    Query Parameters:
    - selected_date_type (str): The type of date range validation ('weekly', 'monthly', 'yearly'). Required.
    - start_date (str, YYYY-MM-DD): The start date for filtering check-ins and reports. Required.
    - end_date (str, YYYY-MM-DD): The end date for filtering check-ins and reports. Required.

    Returns:
        Response: A list of dictionaries, where each dictionary represents an employee
        with their name, workstation, collected revenue, and issue count.
        The list is sorted by 'Collected Revenue' in descending order.
        Example:
        [
            {"Name": "John Doe", "Station": "Main Station", "Collected Revenue": 12345.67, "Issue Count": 5},
            {"Name": "Jane Smith", "Station": "Station B", "Collected Revenue": 8901.23, "Issue Count": 2},
            ...
        ]

    Raises:
        HTTP 400 Bad Request: If any required parameters are missing, date formats are invalid,
                              or the date range does not match the 'selected_date_type' rules.
    """
    selected_date_type = request.query_params.get("selected_date_type")
    start_date_str = request.query_params.get("start_date")
    end_date_str = request.query_params.get("end_date")

    # 1. Validate request parameters and parse dates using the helper function
    if not all([selected_date_type, start_date_str, end_date_str]):
        missing_params = [
            param_name
            for param_name, param_value in {
                "selected_date_type": selected_date_type,
                "start_date": start_date_str,
                "end_date": end_date_str,
            }.items()
            if not param_value
        ]
        return Response(
            {"error": f"Missing required parameters: {', '.join(missing_params)}."},
            status=status.HTTP_400_BAD_REQUEST,
        )

    try:
        start_date, inclusive_end_date = parse_and_validate_date_range(
            start_date_str, end_date_str, selected_date_type
        )
    except ValidationError as e:
        return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

    # 2. Prepare filter conditions for check-ins and reports
    common_filters = Q(
        checkin_time__range=[start_date, inclusive_end_date],
        status__in=["pass", "paid", "success"],
        employee__isnull=False,  # Only consider check-ins handled by an employee
        station__isnull=False,  # Ensure check-ins are linked to a station
    )

    # 3. Get all relevant check-ins within the date range, annotated with revenue and employee details
    checkins_with_revenue = annotate_revenue_on_checkins(
        Checkin.objects.filter(common_filters)
    ).annotate(
        employee_full_name=Coalesce(
            Concat(F("employee__first_name"), V(" "), F("employee__last_name")),
            F("employee__first_name"),
            F("employee__last_name"),
            V("Unknown Employee"),
        ),
        station_name=F("station__name"),  # Annotate station name directly
    )

    # 4. Aggregate revenue and issue counts per employee and station
    # This involves two main aggregations: one for revenue from check-ins, one for issue counts.

    # Aggregate revenue per employee and station
    revenue_aggregates = checkins_with_revenue.values(
        "employee__id", "employee_full_name", "station__id", "station_name"
    ).annotate(collected_revenue=Coalesce(Sum("revenue"), Decimal(0)))

    # Aggregate issue counts per employee and station
    # We need to consider all employees and stations involved in check-ins during the period.
    issue_aggregates = (
        Report.objects.filter(
            employee_id__in=revenue_aggregates.values_list(
                "employee__id", flat=True
            ),  # Only for employees with checkins
            station_id__in=revenue_aggregates.values_list(
                "station__id", flat=True
            ),  # Only for stations with checkins
            created_at__range=[start_date, inclusive_end_date],
        )
        .values("employee__id", "station__id")
        .annotate(issue_count=Coalesce(Count("id"), 0))
    )

    # Convert issue aggregates to a dictionary for easy lookup
    issues_lookup = {
        (item["employee__id"], item["station__id"]): item["issue_count"]
        for item in issue_aggregates
    }

    # 5. Combine and format the results
    result = []
    for revenue_item in revenue_aggregates:
        employee_id = revenue_item["employee__id"]
        station_id = revenue_item["station__id"]

        issue_count = issues_lookup.get((employee_id, station_id), 0)

        result.append(
            {
                "Name": revenue_item["employee_full_name"],
                "Station": revenue_item["station_name"],
                "Collected Revenue": float(round(revenue_item["collected_revenue"], 2)),
                "Issue Count": issue_count,
            }
        )

    # Sort result by revenue in descending order (frontend compatible)
    result.sort(key=lambda x: x["Collected Revenue"], reverse=True)

    return Response(result)
